# Redis 相关技术
 |          项目              |  意义          |
 | :---                      | :---           |
 | redis-distributed-look    |  分布式锁 ,限流操作     |
 | redis-message-delay       |  消息延迟队列(网页用户浏览量统计,布隆过滤器)    |
- ### Redis 之安装
##### 提前准备好 gcc 环境:
```
yum install gcc-c++
```
##### 接下来下载并安装 Redis:
```
wget http://download.redis.io/releases/redis-5.0.7.tar.gz 
tar -zxvf redis-5.0.7.tar.gz
cd redis-5.0.7/ 
make
make install
```
#### 安装完成后，启动 Redis:
```
redis-server redis.conf
```
![sp20200512_211529_345](https://imgkr.cn-bj.ufileos.com/fed7c9cf-d8c1-40af-973e-00d77b76ca27.png)
- ### 相关配置
##### 首先，修改 redis.conf 配置文件：
![sp20200512_212144_640](https://imgkr.cn-bj.ufileos.com/cf418afb-bc45-4b9e-8ce6-abf6a2b6d08b.png)
##### 配置完成后，保存退出，再次通过 redis-server redis.conf 命令启动 Redis，此时，就是在后台启 动了。
![sp20200512_212239_883](https://imgkr.cn-bj.ufileos.com/0bf02ce3-fe06-4690-b2bc-863e360f5cfe.png)

- ### 连接
```
使用 redis-cli 进行连接  输入ping 返回PONG 则连接成功
```
- ### 远程连接
#### 首先，修改 redis.conf 注释 127.0.0.1 配置文件：
![sp20200512_212645_405](https://imgkr.cn-bj.ufileos.com/08de90e5-09b7-4f49-b61d-0481e14ccd1d.png)
#### 配置密码 配置后 保存退出 重新启动服务
![sp20200512_212905_330](https://imgkr.cn-bj.ufileos.com/7453a760-a33d-4b81-b17f-a9e75dd401da.png)

### redis-distributed-look -- 分布式锁
```text
问题场景:
例如一个简单的用户操作，一个线城去修改用户的状态，首先从数据库中读出用户的状态，然后 在内存中进行修改，修改完成后，再存回去。
在单线程中，这个操作没有问题，但是在多线程 中，由于读取、修改、存 这是三个操作，不是原子操作，所以在多线程中，这样会出问题


实现思路:
分布式锁实现的思路很简单，就是进来一个线城先占位，当别的线城进来操作时，发现已经有人占位 了，就会放弃或者稍后再试。
在 Redis 中，占位一般使用 setnx 指令，先进来的线城先占位，线城的操作执行完成后，再调用 del 指 令释放位子
```
###  - 消息队列
```text
Redis 做消息队列，使用它里边的 List 数据结构就可以实现，我们可以使用 lpush/rpush 操作来实现入 队，
然后使用 lpop/rpop 来实现出队。

在客户端（例如 Java 端），我们会维护一个死循环来不停的从队列中读取消息，并处理，如果队列中 有消息，则直接获取到，如果没有消息，
就会陷入死循环，直到下一次有消息进入，这种死循环会造成 大量的资源浪费，这个时候，我们可以使用之前讲的 blpop/brpop 
```
![](https://imgkr.cn-bj.ufileos.com/098a1f6c-9419-426d-9d72-101283bd14f1.png)

### -消息延迟队列
```text
延迟队列可以通过 zset 来实现，因为 zset 中有一个 score，我们可以把时间作为 score，将 value 存到 redis 中，
然后通过轮询的方式，去不断的读取消息出来。
首先，如果消息是一个字符串，直接发送即可，如果是一个对象，则需要对对象进行序列化，这里我们 使用 JSON 来实现序列化和反序列化。 
```
### Reid位图(操作BIT位置)
```text
用户一年的签到记录，如果你用 string 类型来存储，那你需要 365 个 key/value，操作起来麻烦。通过 位图可以有效的简化这个操作。
它的统计很简单：
01111000111
每天的记录占一个位，365 天就是 365 个位，大概 46 个字节，这样可以有效的节省存储空间，如果有 一天想要统计用户一共签到了多少天，统计 1 的个数即可。
对于位图的操作，可以直接操作对应的字符串（get/set），可以直接操作位（getbit/setbit）. 
```
### HyperLogLog(pv and uv访问流量记录)
```text
一般我们评估一个网站的访问量，有几个主要的参数：
pv，Page View，网页的浏览量 uv，User View，访问的用户
```
### 布隆过滤器(比如头条推荐类似文章)
```text
前面所说的新闻推送过滤算是一个应用场景。
解决 Redis 穿透或者又叫缓存击穿问题。
假设我有 1亿 条用户数据，现在查询用户要去数据库中查，效率低而且数据库压力大，所以我们会把请 求首先在 Redis 中处理（活跃用户存在 Redis 中），
Redis 中没有的用户，再去数据库中查询。 现在可能会存在一种恶意请求，这个请求携带上了很多不存在的用户，这个时候 Redis 无法拦截下来请 求，所以请求会直接跑到数据库里去。
这个时候，这些恶意请求会击穿我们的缓存，甚至数据库，进而 引起“雪崩效应”。 为了解决这个问题，我们就可以使用布隆过滤器。将 1亿条用户数据存在 Redis 中不现实，
但是可以存 在布隆过滤器中，请求来了，首先去判断数据是否存在，如果存在，再去数据库中查询，否则就不去数 据库中查询。 
```
### 限流(在某个时间窗有限制访问次数)
```text
Pipeline（管道）本质上是由客户端提供的一种操作。Pipeline 通过调整指令列表的读写顺序，可以大 幅度的节省 IO 时间，提高效率。 
Redis4.0 开始提供了一个 Redis-Cell 模块，这个模块使用漏斗算法，提供了一个非常好用的限流指令。
漏斗算法就像名字一样，是一个漏斗，请求从漏斗的大口进，然后从小口出进入到系统中，这样，无论 是多大的访问量，终进入到系统中的请求，都是固定的
使用漏斗算法，需要我们首先安装 Redis-Cell 模块：
 https://github.com/brandur/redis-cell
```
